import { SQL } from 'bun';
import { readdirSync, readFileSync } from 'fs';
import { resolve } from 'path';

// 数据库连接 - 与 Base.ts 保持一致
const DSN = "mysql://root:root@localhost:3306/mydb";
const sql = new SQL(DSN);

// 数据库类型判断
const isMySQL = DSN.startsWith('mysql');
const isSQLite = DSN.startsWith('sqlite');
const isPostgres = DSN.startsWith('postgres');

// TypeScript 类型 -> SQL 类型映射
function tsTypeToSql(tsType: string, fieldName: string, isOptional: boolean): string {
    const notNull = isOptional ? '' : ' NOT NULL';
    const type = tsType.replace(/\?$/, '').trim();
    
    if (isMySQL) {
        switch (type) {
            case 'string': return `VARCHAR(255)${notNull}`;
            case 'number': return `DECIMAL(10,2)${notNull}`;
            case 'bigint': return `BIGINT${notNull}`;
            case 'boolean': return `TINYINT(1)${notNull}`;
            case 'Date': return `DATETIME${notNull}`;
            case 'text': return `TEXT${notNull}`;
            case 'json': return `JSON${notNull}`;
            default: return `VARCHAR(255)${notNull}`;
        }
    }
    
    if (isPostgres) {
        switch (type) {
            case 'string': return `VARCHAR(255)${notNull}`;
            case 'number': return `NUMERIC(10,2)${notNull}`;
            case 'bigint': return `BIGINT${notNull}`;
            case 'boolean': return `BOOLEAN${notNull}`;
            case 'Date': return `TIMESTAMP${notNull}`;
            case 'text': return `TEXT${notNull}`;
            case 'json': return `JSONB${notNull}`;
            default: return `VARCHAR(255)${notNull}`;
        }
    }
    
    // SQLite
    switch (type) {
        case 'string': return `TEXT${notNull}`;
        case 'number': return `REAL${notNull}`;
        case 'bigint': return `INTEGER${notNull}`;
        case 'boolean': return `INTEGER${notNull}`;
        case 'Date': return `TEXT${notNull}`;
        case 'text': return `TEXT${notNull}`;
        case 'json': return `TEXT${notNull}`;
        default: return `TEXT${notNull}`;
    }
}

// 主键语法
function getPrimaryKey(): string {
    if (isMySQL) return 'INT AUTO_INCREMENT PRIMARY KEY';
    if (isPostgres) return 'SERIAL PRIMARY KEY';
    return 'INTEGER PRIMARY KEY AUTOINCREMENT';
}

// 类名 -> 表名（驼峰转下划线复数）
function classToTable(className: string): string {
    const snake = className.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
    return snake.endsWith('s') ? snake : snake + 's';
}

// 解析 TS 类文件，提取字段定义
function parseClass(filePath: string): { className: string; fields: { name: string; type: string; optional: boolean }[] } | null {
    const content = readFileSync(filePath, 'utf-8');
    
    // 匹配类名（继承自 Base）
    const classMatch = content.match(/export\s+class\s+(\w+)\s+extends\s+Base/);
    if (!classMatch) return null;
    
    const className = classMatch[1];
    const fields: { name: string; type: string; optional: boolean }[] = [];
    
    // 匹配属性定义: name: string = '' 或 name?: string 或 price: number // 注释
    const propRegex = /^\s+(\w+)(\?)?:\s*(string|number|bigint|boolean|Date|text|json)(?:\s*=.*?)?;?(?:\s*\/\/.*)?$/gm;
    let match;
    
    while ((match = propRegex.exec(content)) !== null) {
        const [, name, optional, type] = match;
        // 跳过 id（自动生成主键）
        if (name === 'id') continue;
        fields.push({ name, type, optional: !!optional });
    }
    
    return { className, fields };
}

// 生成 CREATE TABLE SQL
function generateCreateTable(className: string, fields: { name: string; type: string; optional: boolean }[]): string {
    const table = classToTable(className);
    const pk = getPrimaryKey();
    
    const columns = [
        `id ${pk}`,
        ...fields.map(f => `${f.name} ${tsTypeToSql(f.type, f.name, f.optional)}`)
    ];
    
    return `CREATE TABLE IF NOT EXISTS ${table} (\n    ${columns.join(',\n    ')}\n)`;
}

// 生成 SQL 文件（不执行）
export async function generate(arpcDir?: string): Promise<string> {
    const dir = arpcDir || resolve(import.meta.dir, '../arpc');
    const files = readdirSync(dir).filter(f => f.endsWith('.ts'));
    
    // 生成 3 份 SQL
    const dbTypes = [
        { name: 'mysql', check: () => true },
        { name: 'sqlite', check: () => false },
        { name: 'postgres', check: () => false }
    ];
    
    for (const db of dbTypes) {
        const outPath = resolve(import.meta.dir, `../../db.${db.name}.sql`);
        const statements: string[] = [
            `-- Auto-generated by migrate.ts`,
            `-- Database: ${db.name.toUpperCase()}`,
            `-- Generated at: ${new Date().toISOString()}`,
            ''
        ];
        
        for (const file of files) {
            const filePath = resolve(dir, file);
            const parsed = parseClass(filePath);
            if (!parsed || parsed.fields.length === 0) continue;
            
            const ddl = generateCreateTableForDb(parsed.className, parsed.fields, db.name);
            statements.push(`-- ${parsed.className}`);
            statements.push(ddl + ';');
            statements.push('');
        }
        
        await Bun.write(outPath, statements.join('\n'));
        console.log(`[generate] ${db.name.toUpperCase()} SQL 已写入: ${outPath}`);
    }
    
    // 返回默认执行的 MySQL 文件
    return resolve(import.meta.dir, '../../db.mysql.sql');
}

// 根据数据库类型生成 CREATE TABLE
function generateCreateTableForDb(className: string, fields: { name: string; type: string; optional: boolean }[], dbType: string): string {
    const table = classToTable(className);
    
    // 主键
    let pk: string;
    if (dbType === 'mysql') pk = 'INT AUTO_INCREMENT PRIMARY KEY';
    else if (dbType === 'postgres') pk = 'SERIAL PRIMARY KEY';
    else pk = 'INTEGER PRIMARY KEY AUTOINCREMENT';
    
    const columns = [
        `id ${pk}`,
        ...fields.map(f => `${f.name} ${tsTypeToSqlForDb(f.type, f.optional, dbType)}`)
    ];
    
    return `CREATE TABLE IF NOT EXISTS ${table} (\n    ${columns.join(',\n    ')}\n)`;
}

// 根据数据库类型转换 TS 类型
function tsTypeToSqlForDb(tsType: string, isOptional: boolean, dbType: string): string {
    const notNull = isOptional ? '' : ' NOT NULL';
    const type = tsType.replace(/\?$/, '').trim();
    
    if (dbType === 'mysql') {
        switch (type) {
            case 'string': return `VARCHAR(255)${notNull}`;
            case 'number': return `DECIMAL(10,2)${notNull}`;
            case 'bigint': return `BIGINT${notNull}`;
            case 'boolean': return `TINYINT(1)${notNull}`;
            case 'Date': return `DATETIME${notNull}`;
            case 'text': return `TEXT${notNull}`;
            case 'json': return `JSON${notNull}`;
            default: return `VARCHAR(255)${notNull}`;
        }
    }
    
    if (dbType === 'postgres') {
        switch (type) {
            case 'string': return `VARCHAR(255)${notNull}`;
            case 'number': return `NUMERIC(10,2)${notNull}`;
            case 'bigint': return `BIGINT${notNull}`;
            case 'boolean': return `BOOLEAN${notNull}`;
            case 'Date': return `TIMESTAMP${notNull}`;
            case 'text': return `TEXT${notNull}`;
            case 'json': return `JSONB${notNull}`;
            default: return `VARCHAR(255)${notNull}`;
        }
    }
    
    // SQLite
    switch (type) {
        case 'string': return `TEXT${notNull}`;
        case 'number': return `REAL${notNull}`;
        case 'bigint': return `INTEGER${notNull}`;
        case 'boolean': return `INTEGER${notNull}`;
        case 'Date': return `TEXT${notNull}`;
        case 'text': return `TEXT${notNull}`;
        case 'json': return `TEXT${notNull}`;
        default: return `TEXT${notNull}`;
    }
}

// 执行 SQL 文件
export async function run(sqlFile?: string): Promise<void> {
    const filePath = sqlFile || resolve(import.meta.dir, '../../db.sql');
    const file = Bun.file(filePath);
    
    if (!await file.exists()) {
        console.error(`[error] 文件不存在: ${filePath}`);
        console.log('[tip] 请先运行: bun run src/core/migrate.ts generate');
        return;
    }
    
    const content = await file.text();
    // 移除注释行，然后按分号分割
    const cleanContent = content.split('\n')
        .filter(line => !line.trim().startsWith('--'))
        .join('\n');
    const statements = cleanContent
        .split(';')
        .map(s => s.trim())
        .filter(s => s.length > 0);
    
    console.log(`[run] 执行 SQL 文件: ${filePath}`);
    console.log(`[run] 共 ${statements.length} 条语句\n`);
    
    for (const stmt of statements) {
        try {
            await sql.unsafe(stmt);
            const table = stmt.match(/CREATE TABLE.*?\s+(\w+)/i)?.[1];
            console.log(`[ok] ${table || 'statement'}`);
        } catch (e: any) {
            console.error(`[error] ${e.message}`);
        }
    }
    
    console.log('\n[run] 执行完成');
}

// 扫描并迁移（生成 + 执行）
export async function migrate(arpcDir?: string): Promise<void> {
    const sqlFile = await generate(arpcDir);
    await run(sqlFile);
}

// 命令行执行
if (import.meta.main) {
    const cmd = process.argv[2];
    
    if (cmd === 'generate' || cmd === 'gen') {
        // 生成并执行 SQL
        await migrate();
    } else if (cmd === 'run') {
        // 只执行 SQL 文件
        await run();
    } else {
        // 默认：生成 + 执行
        await migrate();
    }
}
